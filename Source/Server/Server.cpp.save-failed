#include "Server.hpp"

Server::Server(std::string const& propertiesFile, std::string const& logFile)
: mThread(&Server::run,this)
, mRunning(false)
, mListener()
, mListeningState(false)
, mSettingsFile(propertiesFile)
, mConnectedPlayers(0)
, mPeers(1)
{
    if (!loadSettings())
    {
        createSettings();
        saveSettings();
    }

    openLog(logFile);

    mMaxPlayers = 10;
    mPort = 4567;
    mClientTimeoutTime = sf::seconds(3.0f);
    mUpdateInterval = sf::seconds(1.f/60.f);

    mListener.setBlocking(false);
	mPeers[0].reset(new Peer());

    *this << std::string(getTimeFormat() + "[Server] ") << "Server Version 0.1" << std::endl;
	*this << std::string(getTimeFormat() + "[Server] ") << " - Max Players : " << mMaxPlayers << std::endl;
	*this << std::string(getTimeFormat() + "[Server] ") << " - Server Port : " << mPort << std::endl;

	start();
}

Server::~Server()
{
    stop();
}

void Server::start()
{
    *this << std::string(getTimeFormat() + "[Server] ") << "Starting server..." << std::endl;

    mRunning = true;

    mThread.launch();

    *this << std::string(getTimeFormat() + "[Server] ") << "Server started !" << std::endl;
}

void Server::stop()
{
    if (mRunning)
    {
        *this << std::string(getTimeFormat() + "[Server] ") << "Stopping server" << std::endl;

        setListening(false);

        sf::Packet packet;
        packet << Packet::ServerStopped;
        sendToAll(packet);

        mRunning = false;

        mThread.wait();

        *this << std::string(getTimeFormat() + "[Server] ") << "Server stopped !" << std::endl;
    }
}

bool Server::isRunning() const
{
    return mRunning;
}

void Server::sendToAll(sf::Packet& packet)
{
    for (std::size_t i = 0; i < mPeers.size(); i++)
    {
        if (mPeers[i]->isConnected())
        {
            mPeers[i]->send(packet);
        }
    }
}

void Server::sendToPeer(sf::Packet& packet, int peerId)
{
    for (std::size_t i = 0; i < mPeers.size(); i++)
    {
        if (mPeers[i]->isConnected() && mPeers[i]->getId() == peerId)
        {
            mPeers[i]->send(packet);
        }
    }
}

void Server::sendToPeer(sf::Packet& packet, Peer& peer)
{
    if (peer.isConnected())
    {
        peer.send(packet);
    }
}

void Server::handleCommand(std::string const& command)
{
    std::vector<std::string> args = splitArguments(command);
    if (args.size() == 0)
        return;

    if (args[0] == "stop")
    {
        stop();
    }
    else if (args[0] == "help")
    {
        *this << std::string(getTimeFormat() + "[Server] ") << "help : Display the list of commands" << std::endl;
        *this << std::string(getTimeFormat() + "[Server] ") << "stop : Stop the server" << std::endl;
    }
}

std::vector<std::string> Server::splitArguments(std::string const& command)
{
    std::vector<std::string> args;
    std::stringstream ss(command);
    std::string arg;
    while (std::getline(ss,arg,' '))
    {
        args.push_back(arg);
    }
    return args;
}

std::string Server::getSettings(std::string const& id) const
{
    if (mSettings.find(id) != mSettings.end())
    {
        return mSettings.at(id);
    }
    else
    {
        return "";
    }
}

bool Server::loadSettings()
{
    std::ifstream file(mSettingsFile);
    if (!file)
    {
        return false;
    }

    std::string line;
    while (std::getline(file,line))
    {
        if(line.size() > 0 && line[0] != '#')
        {
            size_t index = 0;
            while(std::isspace(line[index]))
                index++;
            const size_t beginKeyString = index;
            while(!std::isspace(line[index]) && line[index] != '=')
                index++;
            const std::string key = line.substr(beginKeyString, index - beginKeyString);
            while(std::isspace(line[index]) || line[index] == '=')
                index++;
            const std::string value = line.substr(index, line.size() - index);

            mSettings[key] = value;
        }
    }

    file.close();
    return true;
}

bool Server::saveSettings()
{
    std::ofstream file(mSettingsFile);
    if (!file)
    {
        return false;
    }

    for (auto itr = mSettings.begin(); itr != mSettings.end(); itr++)
    {
        file << itr->first << "=" << itr->second << std::endl;
    }

    file.close();
    return true;
}

void Server::createSettings()
{
}

std::string Server::getTimeFormat()
{
    std::string actualTime;

    char hour[4];
    char minute[4];
    char second[4];

    time_t rawtime;
    time(&rawtime);
    struct tm* timeInfo;
    timeInfo = localtime(&rawtime);
    strftime(hour,5,"%H",timeInfo);
    strftime(minute,5,"%M",timeInfo);
    strftime(second,5,"%S",timeInfo);

    actualTime = "[" + std::string(hour) + ":" + std::string(minute) + ":" + std::string(second) + "] ";

    return actualTime;
}

bool Server::openLog(std::string const& logFile)
{
    if (logFile != "" && !mLog.is_open())
    {
        mLog.open(logFile);
    }
    return mLog.is_open();
}

bool Server::isLogOpen() const
{
    return mLog.is_open();
}

std::ofstream& Server::getLogStream()
{
    return mLog;
}

void Server::setListening(bool enable)
{
    if (enable) // Check if it isn't already listening
	{
		if (!mListeningState)
        {
            mListeningState = (mListener.listen(mPort) == sf::TcpListener::Done);
        }
	}
	else
	{
		mListener.close();
		mListeningState = false;
	}
}

void Server::run()
{
    setListening(true);

    sf::Clock updateClock;

    while (isRunning())
    {
        handlePackets();
        handleConnections();

        if (updateClock.getElapsedTime() > mUpdateInterval)
        {
            update(mUpdateInterval);
            updateClock.restart();
        }

        sf::sleep(sf::milliseconds(100.f));
    }
}

void Server::update(sf::Time dt)
{

}

void Server::handlePackets()
{
    bool detectedTimeout = false;

	for (std::size_t i = 0; i < mConnectedPlayers; i++)
	{
		if (mPeers[i]->isConnected())
		{
			sf::Packet packet;
			while (mPeers[i]->poll(packet))
			{
                handlePacket(packet,*mPeers[i], detectedTimeout);
				packet.clear();
			}

			if (mPeers[i]->getLastPacketTime() > mClientTimeoutTime)
			{
				mPeers[i]->timedOut();
				detectedTimeout = true;
			}
		}
	}

	if (detectedTimeout)
		handleDisconnections();
}

void Server::handlePacket(sf::Packet& packet, Peer& peer, bool& detectedTimeout)
{
    sf::Int32 packetType;
    packet >> packetType;

    switch (packetType)
    {
        default: break;
    }
}

void Server::handleConnections()
{
    if (!mListeningState)
		return;

	if (mListener.accept(mPeers[mConnectedPlayers]->getSocketIn()) == sf::TcpListener::Done)
	{
		if (mPeers[mConnectedPlayers]->connect())
        {
            mConnectedPlayers++;

            if (mConnectedPlayers >= mMaxPlayers)
                setListening(false);
            else
                mPeers.push_back(Peer::Ptr(new Peer()));
        }
	}
}

void Server::handleDisconnections()
{
    for (auto itr = mPeers.begin(); itr != mPeers.end(); )
	{
		if ((*itr)->hasTimedOut())
		{
			mConnectedPlayers--;

			itr = mPeers.erase(itr);

			if (mConnectedPlayers < mMaxPlayers)
			{
				mPeers.push_back(Peer::Ptr(new Peer()));
				setListening(true);
			}
        }
		else
		{
			++itr;
		}
	}
}

Server& operator<<(Server& server, std::string const& v)
{
    if (server.isLogOpen())
    {
        server.getLogStream() << v;
    }
    std::cout << v;
    return server;
}

Server& operator<<(Server& server, std::size_t v)
{
    if (server.isLogOpen())
    {
        server.getLogStream() << v;
    }
    std::cout << v;
    return server;
}

Server& operator<<(Server& server, sf::Time v)
{
    if (server.isLogOpen())
    {
        server.getLogStream() << v.asSeconds();
    }
    std::cout << v.asSeconds();
    return server;
}
